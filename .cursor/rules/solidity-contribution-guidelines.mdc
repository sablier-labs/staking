---
description:
globs:
alwaysApply: true
---
# Solidity Contribution Guidelines

## General Principles

- **Think first, code second**: Minimize the number of lines changed and consider ripple effects across the codebase.
- **Prefer simplicity**: Fewer moving parts ➜ fewer bugs and lower audit overhead.
- **Security first**: Review every change with an adversarial mindset.
- **Documentation**: Document every contract, interface, library, function, and variable with comprehensive NatSpec comments.

## Naming conventions

- Contracts, interfaces, and libraries are in `PascalCase`
- Constants are in `SNAKE_CASE`
- Functions and variables and are in `camelCase`
- Internal and private functions and variables start with `_`
- To avoid shadowing state variables, function parameters have a trailing `_`
- Errors follow the convention such as `Sablier<ContractName>_<ErrorName>`.
- Directories are in `kebab-case`
- File name are in either `PascalCase` or `camelCase`

## Assembly Usage Rules

| Rule | Rationale |
|------|-----------|
| Use assembly only when essential | Keeps code readable and auditable |
| Assembly is mandatory for low-level external calls | Gives full control over call parameters & return data, and saves gas |
| Precede every assembly block with justification and pseudocode | Documents intent for reviewers |
| Mark assembly blocks memory-safe when criteria are met | Enables compiler optimizations |

### Assembly Documentation Template
```solidity
// Assembly justification: [1-2 line explanation]
// Equivalent Solidity: [pseudocode showing what this would look like in Solidity]
assembly ("memory-safe") { // only if memory-safe criteria are met
    // assembly code here
}
```

## Error Handling Style

**Always use custom errors with the revert pattern instead of require statements:**

```solidity
// ❌ Don't use require with string messages
require(amount > 0, "Amount must be positive");
require(to != address(0), "Cannot transfer to zero address");

// ✅ Do use custom errors with if/revert pattern
error AmountMustBePositive();
error CannotTransferToZeroAddress();

if (amount == 0) revert AmountZero();
if (to == address(0)) revert ToAddressZero();
```

**Benefits of custom errors:**
- More gas efficient than require strings
- Better error identification in tests and debugging
- Cleaner, more professional code
- Consistent with modern Solidity best practices

## Gas Optimization Guidelines

- Keep a dedicated **Gas Optimization** section in PR descriptions
- Justify any measurable gas deltas
- Prefer `calldata` over `memory`
- Limit storage operations (`sstore`, `sload`); cache in memory
- Use forge snapshot and benchmarking commands

## Handling "Stack Too Deep" Errors

1. **Struct hack (tests only)**: Bundle local variables into a temporary struct
2. **Scoped blocks**: Wrap code in `{ ... }` to drop unused vars from the stack
3. **Internal helper functions**: Encapsulate logic to shorten call frames
4. **Refactor first**: Delete unnecessary variables before other tricks

## Security Checklist

- Review every change with an adversarial mindset
- Favor the simplest design that meets requirements
- After coding, ask: "What new attack surface did I introduce?"
- Reject any change that raises security risk without strong justification

## Verification Workflow

```bash
just build                    # compile
just test                     # full test suite
```

## File References

Main contract file: [SablierStaking.sol](mdc:src/SablierStaking.sol)
Foundry configuration: [foundry.toml](mdc:foundry.toml)
Package configuration: [package.json](mdc:package.json)
