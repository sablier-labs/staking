---
description:
globs:
alwaysApply: true
---
# Testing Guidelines

## Core Testing Principles

**Every feature or change MUST have comprehensive tests before creating a PR**. This is non-negotiable for maintaining code quality and preventing regressions.

## Naming conventions

- Test file names end in `.t.sol`, while scripts end in `.s.sol`
- Test functions follow the convention `test(Fork)?(Fuzz)?_(RevertWhen_){1})?\w{1,}`. Here is a comprehensive list:
    - "test_Description",
    - "test_Increment",
    - "testFuzz_Description",
    - "testFork_Description",
    - "testForkFuzz_Description",
    - "testForkFuzz_Description_MoreInfo",
    - "test_RevertIf_Condition",
    - "test_RevertWhen_Condition",
    - "test_RevertOn_Condition",
    - "test_RevertOn_Condition_MoreInfo",
    - "testFuzz_RevertIf_Condition",
    - "testFuzz_RevertWhen_Condition",
    - "testFuzz_RevertOn_Condition",
    - "testFuzz_RevertOn_Condition_MoreInfo",
    - "testForkFuzz_RevertIf_Condition",
    - "testForkFuzz_RevertWhen_Condition",
    - "testForkFuzz_RevertOn_Condition",
    - "testForkFuzz_RevertOn_Condition_MoreInfo",
    - "testForkFuzz_RevertOn_Condition_MoreInfo_Wow",
    - "testForkFuzz_RevertOn_Condition_MoreInfo_Wow_As_Many_Underscores_As_You_Want",

## When to Write Tests

- **New Features**: Write tests that demonstrate the complete flow and all edge cases
- **Bug Fixes**: Add tests that reproduce the bug and verify the fix
- **Refactoring**: Ensure existing tests still pass; add new ones if behavior changes
- **Gas Optimizations**: Include benchmark tests showing before/after comparisons

## Types of Required Tests

### Unit Tests
- Write clear unit tests that demonstrate the general flow of your feature/change
- Test both happy paths and failure cases
- Include edge cases and boundary conditions
- Test revert conditions with specific error messages

### Fuzz Tests
**Fuzz tests are highly encouraged** for all new functionality:
- Use Foundry's built-in fuzzing capabilities
- Apply random arguments to thoroughly test your implementation
- Use Solady's random library for composable randomness when needed

#### Fuzz Test Pattern Example
```solidity
function testFuzz_myFeature(uint256 amount, address user) public {
    // Bound inputs to reasonable ranges
    amount = bound(amount, 1, type(uint128).max);
    vm.assume(user != address(0));

    // Test your feature with random inputs
    myContract.myFeature(amount, user);

    // Assert expected outcomes
    assertEq(myContract.balanceOf(user), amount);
}
```

## Testing Best Practices

- **Don't write redundant tests**: If something is already sufficiently tested, don't duplicate
- **Focus on what changed**: Ensure tests encapsulate your specific changes
- **Test downstream consequences**: Consider ripple effects of your changes
- **Update broken tests**: If your change breaks existing tests, update them thoughtfully
- **Use descriptive test names**: `test_FeatureName_SpecificScenario_ExpectedOutcome()`

## Testing Checklist Before PR

Before opening any PR, ensure:
- [ ] All new functions have unit tests
- [ ] Critical paths have fuzz tests with random inputs
- [ ] Edge cases and revert scenarios are tested
- [ ] Gas benchmarks are included for optimizations
- [ ] All tests pass: `forge test`
- [ ] No test coverage regression: `forge coverage`

## Test Commands

```bash
just test                       # Run all tests
just test --match-test testName # Run specific test
just coverage                   # Check test coverage
just gas-report                 # Gas usage report
```

## Using Test Utilities

The project includes helpful testing utilities:
- Solady's test utils for advanced testing patterns
- Forge-std's test helpers and cheat codes
- Project-specific mocks in `test/utils/mocks/`

## Test File Structure

Example test file structure based on project patterns:
```solidity
// test/integration/concrete/my-feature/myFeature.t.sol
contract MyFeature_Integration_Concrete_Test is Shared_Integration_Concrete_Test {
    function test_RevertWhen_DelegateCall() external {
        // Test delegate call protection
    }

    function test_RevertGiven_InvalidInput() external {
        // Test input validation
    }

    function test_WhenValidInput() external {
        // Test successful execution
    }

    function testFuzz_ValidInputs(uint256 amount) external {
        // Fuzz test with random inputs
    }
}
```

## File References

Example test file: [unstakeLockupNFT.t.sol](mdc:tests/integration/concrete/unstake-lockup-nft/unstakeLockupNFT.t.sol)
Test utilities directory: `tests/utils/`
Integration tests: `tests/integration/`
Fuzz tests: `tests/fuzz/`

Remember: **Well-tested code is trusted code**. Take the time to write thorough tests - they're an investment in the project's reliability and your peace of mind.
